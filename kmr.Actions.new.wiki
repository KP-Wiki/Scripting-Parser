#### Actions

All action parameters are numeric and get mapped to unit/house types according to default tables used in DAT scripts.

Actions are placed in a form **Actions.ACT_NAME(ACT_PARAMETERS);** like so:
```pascal
    if States.GameTime = 300 then
      Actions.PlayerDefeat(0); //Defeat 1st player
```
Also there is a short name for Actions: just **A**, so you could use it as
```pascal
  A.PlayerDefeat(0); //Defeat 1st player
```

<sub>"-" Means this will not be implemented.</sub>

***

Other scripts functions:
* [Mission Scripts Dynamic Events](https://github.com/reyandme/kam_remake/wiki/MissionScriptsDynamicEvents)
* [Mission Scripts Dynamic States](https://github.com/reyandme/kam_remake/wiki/MissionScriptsDynamicStates)
* [Mission Scripts Dynamic Utils](https://github.com/reyandme/kam_remake/wiki/MissionScriptsDynamicUtils)
<br />

| Ver<br>sion | Action Description | Parameters<br>and types | Returns |
| ------- | ------------------------------------ | -------------- | ------- |
| 7000+ | AIArmyType<sub><br/>Sets AI army type</sub> | <sub>**aPlayer**: Byte; <br> **aType**: TKMArmyType; //_Type = (atIronThenLeather, atLeather, atIron, atIronAndLeather)_</sub> | <sub></sub> |
| 7000+ | AIAttackAdd<sub><br/>Add AI attack <br/><b>aPlayer</b> - playerID<br/><b>aRepeating</b> - is attack repeating<br/><b>aDelay</b> - attack delay<br/><b>aTotalMen</b> - total soldiers to attack<br/><b>aMelleCount</b>, <b>aAntiHorseCount</b>, <b>aRangedCount</b>, <b>aMountedCount</b> - soldiers groups count<br/><b>aRandomGroups</b> - use random groups for attack<br/><b>aTarget</b> - attack target of TKMAIAttackTarget type. Possible values:<br/><pre>TKMAIAttackTarget = (<br/> attClosestUnit, //Closest enemy unit<br/> attClosestBuildingFromArmy,<br/>   //Closest building from the group lauching the attack<br/> attClosestBuildingFromStartPos,<br/>   //Closest building from the AI's start position<br/> attCustomPosition<br/>   //Custom point defined with aCustomPosition<br/>);</pre><b>aCustomPosition</b> - TKMPoint for custom position of attack. Used if attCustomPosition was set up as attack target<br/><b>Result</b>: Attack Id, that could be used to remove this attack later on</sub> | <sub>**aPlayer**: Byte; <br> **aRepeating**: Boolean; <br> **aDelay**: Cardinal; <br> **aTotalMen**: Integer; <br> **aMelleCount**: Word; <br> **aAntiHorseCount**: Word; <br> **aRangedCount**: Word; <br> **aMountedCount**: Word; <br> **aRandomGroups**: Boolean; <br> **aTarget**: TKMAIAttackTarget; <br> **aCustomPosition**: TKMPoint;</sub> | <sub>Integer</sub> |
| 7000+ | AIAttackRemove<sub><br/>Remove AI attack by attack ID</sub> | <sub>**aPlayer**: Byte; <br> **aAIAttackId**: Word;</sub> | <sub>Boolean //true, if attack was succesfully removed, false, if attack was not found</sub> |
| 7000+ | AIAttackRemoveAll<sub><br/>Remove all AI attacks</sub> | <sub>**aPlayer**: Byte;</sub> | <sub></sub> |
| 6251 | AIAutoAttackRange<sub><br/>Sets AI auto attack range.<br/>AI groups will automatically attack if you are closer than this many tiles.</sub> | <sub>**aPlayer**: Byte; <br> **aRange**: Word; //_Range (1 to 20)_</sub> | <sub></sub> |
| 5924 | AIAutoBuild<sub><br/>Sets whether the AI should build and manage his own village</sub> | <sub>**aPlayer**: Byte; <br> **aAuto**: Boolean;</sub> | <sub></sub> |
| 5924 | AIAutoDefence<sub><br/>Sets whether the AI should position his soldiers automatically</sub> | <sub>**aPlayer**: Byte; <br> **aAuto**: Boolean;</sub> | <sub></sub> |
| 5932 | AIAutoRepair<sub><br/>Sets whether the AI should automatically repair damaged buildings</sub> | <sub>**aPlayer**: Byte; <br> **aAuto**: Boolean;</sub> | <sub></sub> |
| 5932 | AIDefencePositionAdd<sub><br/>Adds a defence position for the specified AI player</sub> | <sub>**aPlayer**: Byte; <br> **X**: Integer; <br> **Y**: Integer; <br> **aDir**: Byte; <br> **aGroupType**: Byte; <br> **aRadius**: Word; <br> **aDefType**: Byte;</sub> | <sub></sub> |
| 6309 | AIDefencePositionRemove<sub><br/>Removes defence position at X, Y</sub> | <sub>**aPlayer**: Byte; <br> **X**: Integer; <br> **Y**: Integer;</sub> | <sub></sub> |
| 6323 | AIDefencePositionRemoveAll<sub><br/>Removes all defence positions for specified AI player</sub> | <sub>**aPlayer**: Byte;</sub> | <sub></sub> |
| 6251 | AIDefendAllies<sub><br/>Sets whether AI should defend units and houses of allies as if they were its own</sub> | <sub>**aPlayer**: Byte; <br> **aDefend**: Boolean;</sub> | <sub></sub> |
| 5778 | AIEquipRate<sub><br/>Sets the warriors equip rate for AI.</sub> | <sub>**aPlayer**: Byte; <br> **aType**: Byte; //_type: 0 - leather, 1 - iron_ <br> **aRate**: Word;</sub> | <sub></sub> |
| 5778 | AIGroupsFormationSet<sub><br/>Sets the formation the AI uses for defence positions</sub> | <sub>**aPlayer**: Byte; <br> **aType**: Byte; <br> **aCount**: Word; <br> **aColumns**: Word;</sub> | <sub></sub> |
| 5924 | AIRecruitDelay<sub><br/>Sets the number of ticks before the specified AI will start training recruits</sub> | <sub>**aPlayer**: Byte; <br> **aDelay**: Cardinal;</sub> | <sub></sub> |
| 5345 | AIRecruitLimit<sub><br/>Sets the number of recruits the AI will keep in each barracks</sub> | <sub>**aPlayer**: Byte; <br> **aLimit**: Byte;</sub> | <sub></sub> |
| 5924 | AISerfsPerHouse<sub><br/>Sets the number of serfs the AI will train per house.<br/>Can be a decimal (0.25 for 1 serf per 4 houses)</sub> | <sub>**aPlayer**: Byte; <br> **aSerfs**: Single;</sub> | <sub></sub> |
| 5932 | AISoldiersLimit<sub><br/>Sets the maximum number of soldiers the AI will train, or -1 for unlimited</sub> | <sub>**aPlayer**: Byte; <br> **aLimit**: Integer;</sub> | <sub></sub> |
| 6251 | AIStartPosition<sub><br/>Sets the AI start position which is used for targeting AI attacks</sub> | <sub>**aPlayer**: Byte; <br> **X**: Word; <br> **Y**: Word;</sub> | <sub></sub> |
| 5924 | AIWorkerLimit<sub><br/>Sets the maximum number of laborers the AI will train</sub> | <sub>**aPlayer**: Byte; <br> **aLimit**: Byte;</sub> | <sub></sub> |
| 5938 | CinematicEnd<sub><br/>Exits cinematic mode</sub> | <sub>**aPlayer**: Byte;</sub> | <sub></sub> |
| 5938 | CinematicPanTo<sub><br/>Pans the center of the player's screen to the given location over a set number of ticks.<br/>If Duration = 0 then the screen moves instantly.</sub> | <sub>**aPlayer**: Byte; <br> **X**: Word; <br> **Y**: Word; <br> **Duration**: Word;</sub> | <sub></sub> |
| 5938 | CinematicStart<sub><br/>Puts the player in cinematic mode, blocking user input and allowing the screen to be panned</sub> | <sub>**aPlayer**: Byte;</sub> | <sub></sub> |
| 5097 | FogCoverAll<sub><br/>Covers (un-reveals) the entire map in fog of war for player</sub> | <sub>**aPlayer**: Byte;</sub> | <sub></sub> |
| 5097 | FogCoverCircle<sub><br/>Reveals a circle in fog of war for player</sub> | <sub>**aPlayer**: Word; <br> **X**: Word; <br> **Y**: Word; <br> **aRadius**: Word;</sub> | <sub></sub> |
| 5777 | FogCoverRect<sub><br/>Covers a rectangular area in fog of war for player</sub> | <sub>**aPlayer**: Word; <br> **X1**: Word; //_Left coordinate_ <br> **Y1**: Word; //_Top coordinate_ <br> **X2**: Word; //_Right coordinate_ <br> **Y2**: Word; //_Bottom coordinate_</sub> | <sub></sub> |
| 5097 | FogRevealAll<sub><br/>Reveals the entire map in fog of war for player</sub> | <sub>**aPlayer**: Byte;</sub> | <sub></sub> |
| 5097 | FogRevealCircle<sub><br/>Reveals a circle in fog of war for player</sub> | <sub>**aPlayer**: Word; <br> **X**: Word; <br> **Y**: Word; <br> **aRadius**: Word;</sub> | <sub></sub> |
| 5777 | FogRevealRect<sub><br/>Reveals a rectangular area in fog of war for player</sub> | <sub>**aPlayer**: Word; <br> **X1**: Word; //_Left coordinate_ <br> **Y1**: Word; //_Top coordinate_ <br> **X2**: Word; //_Right coordinate_ <br> **Y2**: Word; //_Bottom coordinate_</sub> | <sub></sub> |
| 5057 | GiveAnimal<sub><br/>Adds an animal to the game and returns the unit ID or -1 if the animal was not able to be added</sub> | <sub>**aType**: Word; <br> **X**: Word; <br> **Y**: Word;</sub> | <sub>Integer</sub> |
| 6311 | GiveField<sub><br/>Adds finished field and returns true if field was successfully added</sub> | <sub>**aPlayer**: Word; <br> **X**: Word; <br> **Y**: Word;</sub> | <sub>Boolean</sub> |
| 7000+ | GiveFieldAged<sub><br/>Sets field age if tile is corn field, or adds finished field and sets its age if tile is empty, and returns true if this was successfully done</sub> | <sub>**aPlayer**: Word; <br> **X**: Word; <br> **Y**: Word; <br> **aStage**: Byte; //_0..6, sets the field growth stage. 0 = empty field; 6 = corn has been cut_ <br> **aRandomAge**: Boolean; //_RandomAge sets FieldAge to random, according to specified stage. Makes fields more realistic_</sub> | <sub>Boolean</sub> |
| 5057 | GiveGroup<sub><br/>Give player group of warriors and return the group ID or -1 if the group was not able to be added</sub> | <sub>**aPlayer**: Word; <br> **aType**: Word; <br> **X,Y**: Word; <br> **aDir**: Word; <br> **aCount**: Word; <br> **aColumns**: Word; //_Units per row_</sub> | <sub>Integer</sub> |
| 5097 | GiveHouse<sub><br/>Give player a built house and returns the house ID or -1 if the house was not able to be added</sub> | <sub>**aPlayer**: Integer; <br> **aHouseType**: Integer; <br> **X,Y**: Integer;</sub> | <sub>Integer</sub> |
| 6288 | GiveHouseSite<sub><br/>Give player a digged house area and returns House ID or -1 if house site was not able to be added.<br/>If AddMaterials = True, wood and stone will be added</sub> | <sub>**aPlayer**: Integer; <br> **aHouseType**: Integer; <br> **X**: Integer; <br> **Y**: Integer; <br> **aAddMaterials**: Boolean;</sub> | <sub>Integer</sub> |
| 6311 | GiveRoad<sub><br/>Adds finished road and returns true if road was successfully added</sub> | <sub>**aPlayer**: Word; <br> **X**: Word; <br> **Y**: Word;</sub> | <sub>Boolean</sub> |
| 5057 | GiveUnit<sub><br/>Give player a single citizen and returns the unit ID or -1 if the unit was not able to be added</sub> | <sub>**aPlayer**: Word; <br> **aType**: Word; <br> **X**: Word; <br> **Y**: Word; <br> **aDir**: Word;</sub> | <sub>Integer</sub> |
| 5057 | GiveWares<sub><br/>Adds amount of wares to players 1st Store</sub> | <sub>**aPlayer**: Word; <br> **aType**: Word; <br> **aCount**: Word;</sub> | <sub></sub> |
| 5165 | GiveWeapons<sub><br/>Adds amount of weapons to players 1st Barracks</sub> | <sub>**aPlayer**: Word; <br> **aType**: Word; <br> **aCount**: Word;</sub> | <sub></sub> |
| 6277 | GroupBlockOrders<sub><br/>Disables (Disable = True) or enables (Disable = False) control over specifed warriors group</sub> | <sub>**aGroupID**: Integer; <br> **aBlock**: Boolean;</sub> | <sub></sub> |
| 5993 | GroupDisableHungryMessage<sub><br/>Sets whether the specified group will alert the player when they become hungry<br/>(true to disable hunger messages, false to enable them)</sub> | <sub>**aGroupID**: Integer; <br> **aDisable**: Boolean;</sub> | <sub></sub> |
| 5993 | GroupHungerSet<sub><br/>Set hunger level for all group members</sub> | <sub>**aGroupID**: Integer; <br> **aHungerLevel**: Integer; //_Hunger level (ticks until death)_</sub> | <sub></sub> |
| 5993 | GroupKillAll<sub><br/>Kills all members of the specified group</sub> | <sub>**aGroupID**: Integer; <br> **aSilent**: Boolean;</sub> | <sub></sub> |
| 5057 | GroupOrderAttackHouse<sub><br/>Order the specified group to attack the specified house</sub> | <sub>**aGroupID**: Integer; <br> **aHouseID**: Integer;</sub> | <sub></sub> |
| 5057 | GroupOrderAttackUnit<sub><br/>Order the specified group to attack the specified unit</sub> | <sub>**aGroupID**: Integer; <br> **aUnitID**: Integer;</sub> | <sub></sub> |
| 5057 | GroupOrderFood<sub><br/>Order the specified group to request food</sub> | <sub>**aGroupID**: Integer;</sub> | <sub></sub> |
| 5057 | GroupOrderHalt<sub><br/>Order the specified group to halt</sub> | <sub>**aGroupID**: Integer;</sub> | <sub></sub> |
| 5057 | GroupOrderLink<sub><br/>Order the first specified group to link to the second specified group</sub> | <sub>**aGroupID**: Integer; <br> **aDestGroupID**: Integer;</sub> | <sub></sub> |
| 5057 | GroupOrderSplit<sub><br/>Order the specified group to split in half.<br/>Return the newly create group ID or -1 if splitting failed (e.g. only 1 member)</sub> | <sub>**aGroupID**: Integer;</sub> | <sub>Integer</sub> |
| 6338 | GroupOrderSplitUnit<sub><br/>Splits specified unit from the group.<br/>Returns the newly create group ID or -1 if splitting failed (e.g. only 1 member)</sub> | <sub>**aGroupID**: Integer; <br> **aUnitID**: Integer;</sub> | <sub>Integer</sub> |
| 5057 | GroupOrderStorm<sub><br/>Order the specified group to storm attack</sub> | <sub>**aGroupID**: Integer;</sub> | <sub></sub> |
| 5057 | GroupOrderWalk<sub><br/>Order the specified group to walk somewhere</sub> | <sub>**aGroupID**: Integer; <br> **X**: Word; <br> **Y**: Word; <br> **aDirection**: Word;</sub> | <sub></sub> |
| 5057 | GroupSetFormation<sub><br/>Sets the number of columns (units per row) for the specified group</sub> | <sub>**aGroupID**: Integer; <br> **aNumColumns**: Byte;</sub> | <sub></sub> |
| 6510 | HouseAddBuildingMaterials<sub><br/>Add building materials to the specified WIP house area</sub> | <sub>**aHouseID**: Integer;</sub> | <sub></sub> |
| 6297 | HouseAddBuildingProgress<sub><br/>Add 5 points of building progress to the specified WIP house area</sub> | <sub>**aHouseID**: Integer;</sub> | <sub></sub> |
| 5057 | HouseAddDamage<sub><br/>Add damage to the specified house</sub> | <sub>**aHouseID**: Integer; <br> **aDamage**: Word;</sub> | <sub></sub> |
| 5441 | HouseAddRepair<sub><br/>Reduces damage to the specified house</sub> | <sub>**aHouseID**: Integer; <br> **aRepair**: Word;</sub> | <sub></sub> |
| 5057 | HouseAddWaresTo<sub><br/>Add wares to the specified house</sub> | <sub>**aHouseID**: Integer; <br> **aType**: Word; <br> **aCount**: Word;</sub> | <sub></sub> |
| 5057 | HouseAllow<sub><br/>Sets whether the player is allowed to build the specified house.<br/>Note: The house must still be unlocked normally (e.g. sawmill for farm), use HouseUnlock to override that.</sub> | <sub>**aPlayer**: Word; <br> **aHouseType**: Word; <br> **aAllowed**: Boolean;</sub> | <sub></sub> |
| 10940 | HouseAllowAllyToView<sub><br/>Allows allies to view specified house</sub> | <sub>**aHouseID**: Integer; <br> **aAllow**: Boolean;</sub> | <sub></sub> |
| 10940 | HouseAllowAllyToViewAll<sub><br/>Allows allies to view all houses of specified player</sub> | <sub>**aPlayer**: Byte; <br> **aAllow**: Boolean;</sub> | <sub></sub> |
| 5174 | HouseBarracksEquip<sub><br/>Equips the specified unit from the specified barracks.<br/>Returns the number of units successfully equipped.</sub> | <sub>**aHouseID**: Integer; <br> **aUnitType**: Integer; <br> **aCount**: Integer;</sub> | <sub>Integer</sub> |
| 6125 | HouseBarracksGiveRecruit<sub><br/>Adds a recruit inside the specified barracks</sub> | <sub>**aHouseID**: Integer;</sub> | <sub></sub> |
| 5057 | HouseDeliveryBlock<sub><br/>Sets delivery blocking for the specified house</sub> | <sub>**aHouseID**: Integer; <br> **aDeliveryBlocked**: Boolean;</sub> | <sub></sub> |
| 7000+ | HouseDeliveryMode<sub><br/>Sets delivery mode for the specified house<br/>Possible values for aDeliveryMode parameter:<br/>0 - Delivery closed<br/>1 - Delivery allowed<br/>2 - Take resource out</sub> | <sub>**aHouseID**: Integer; <br> **aDeliveryMode**: Byte;</sub> | <sub></sub> |
| 5263 | HouseDestroy<sub><br/>Destroys the specified house.<br/>Silent means the house will not leave rubble or play destroy sound</sub> | <sub>**aHouseID**: Integer; <br> **aSilent**: Boolean;</sub> | <sub></sub> |
| 5345 | HouseDisableUnoccupiedMessage<sub><br/>Sets whether the specified house displays unoccupied messages to the player</sub> | <sub>**aHouseID**: Integer; <br> **aDisabled**: Boolean;</sub> | <sub></sub> |
| 5057 | HouseRepairEnable<sub><br/>Enables house repair for the specified house</sub> | <sub>**aHouseID**: Integer; <br> **aRepairEnabled**: Boolean;</sub> | <sub></sub> |
| 5174 | HouseSchoolQueueAdd<sub><br/>Adds the specified unit to the specified school's queue.<br/>Returns the number of units successfully added to the queue.</sub> | <sub>**aHouseID**: Integer; <br> **aUnitType**: Integer; <br> **aCount**: Integer;</sub> | <sub>Integer</sub> |
| 5174 | HouseSchoolQueueRemove<sub><br/>Removes the unit from the specified slot of the school queue.<br/>Slot 0 is the unit currently training, slots 1..5 are the queue.</sub> | <sub>**aHouseID**: Integer; <br> **QueueIndex**: Integer;</sub> | <sub></sub> |
| 6015 | HouseTakeWaresFrom<sub><br/>Remove wares from the specified house.<br/>If a serf was on the way to pick up the ware, the serf will abandon his task</sub> | <sub>**aHouseID**: Integer; <br> **aType**: Word; <br> **aCount**: Word;</sub> | <sub></sub> |
| 7000+ | HouseTownHallEquip<sub><br/>Equips the specified unit from the specified TownHall.<br/>Returns the number of units successfully equipped.</sub> | <sub>**aHouseID**: Integer; <br> **aUnitType**: Integer; <br> **aCount**: Integer;</sub> | <sub>Integer</sub> |
| 7000+ | HouseTownHallMaxGold<sub><br/>Set TownHall Max Gold parameter (how many gold could be delivered in it)</sub> | <sub>**aHouseID**: Integer; <br> **aMaxGold**: Integer;</sub> | <sub></sub> |
| 5057 | HouseUnlock<sub><br/>Allows player to build the specified house even if they don't have the house built that normally unlocks it<br/>(e.g. sawmill for farm).<br/>Note: Does not override blocked houses, use HouseAllow for that.</sub> | <sub>**aPlayer**: Word; <br> **aHouseType**: Word;</sub> | <sub></sub> |
| 5099 | HouseWareBlock<sub><br/>Blocks a specific ware in a storehouse or barracks</sub> | <sub>**aHouseID**: Integer; <br> **aWareType**: Integer; <br> **aBlocked**: Boolean;</sub> | <sub></sub> |
| 5165 | HouseWeaponsOrderSet<sub><br/>Sets the amount of the specified weapon ordered to be produced in the specified house</sub> | <sub>**aHouseID**: Integer; <br> **aWareType**: Integer; <br> **aAmount**: Integer;</sub> | <sub></sub> |
| 5099 | HouseWoodcutterChopOnly<sub><br/>Sets whether a woodcutter's hut is on chop-only mode</sub> | <sub>**aHouseID**: Integer; <br> **aChopOnly**: Boolean;</sub> | <sub></sub> |
| 7000+ | HouseWoodcutterMode<sub><br/>Sets woodcutter's hut woodcutter mode<br/>Possible values for aWoodcutterMode parameter are:<br/>0 - Chop And Plant<br/>1 - Chop only<br/>2 - Plant only</sub> | <sub>**aHouseID**: Integer; <br> **aWoodcutterMode**: Byte;</sub> | <sub></sub> |
| 6067 | Log<sub><br/>Writes a line of text to the game log file. Useful for debugging.<br/>Note that many calls to this procedure will have a noticeable performance impact,<br/>as well as creating a large log file, so it is recommended you don't use it outside of debugging</sub> | <sub>**aText**: AnsiString;</sub> | <sub></sub> |
| 6587 | MapTileHeightSet<sub><br/>Sets the height of the terrain at the top left corner (vertex) of the tile at the specified XY coordinates.<br/>Returns true if the change succeeded or false if it failed.<br/>The change will fail if it would cause a unit to become stuck or a house to be damaged</sub> | <sub>**X**: Integer; <br> **Y**: Integer; <br> **Height**: Integer; //_Height (0..100)_</sub> | <sub>Boolean</sub> |
| 6587 | MapTileObjectSet<sub><br/>Sets the terrain object on the tile at the specified XY coordinates.<br/>Object IDs can be seen in the map editor on the objects tab.<br/>Object 61 is "block walking". To set no object, use object type 255.<br/>Returns true if the change succeeded or false if it failed.<br/>The change will fail if it would cause a unit to become stuck or a house/field to be damaged</sub> | <sub>**X**: Integer; <br> **Y**: Integer; <br> **Obj**: Integer; //_Object type (0..255)_</sub> | <sub>Boolean</sub> |
| 7000+ | MapTilesArraySet<sub><br/>Sets array of tiles info, with possible change of<br/>1. terrain (tile type) and/or rotation (same as for MapTileSet),<br/>2. tile height (same as for MapTileHeightSet)<br/>3. tile object (same as for MapTileObjectSet)<br/>Works much faster, then applying all changes successively for every tile, because pathfinding compute is executed only once after all changes have been done<br/><pre>TKMTerrainTileBrief = record<br/>  X, Y: Byte;     // Tile map coordinates<br/>  Terrain: Byte;  // Terrain tile type (0..255)<br/>  Rotation: Byte; // Tile rotation (0..3)<br/>  Height: Byte;   // Heigth (0..100)<br/>  Obj: Byte;      // Object (0..255)<br/>  ChangeSet: TKMTileChangeTypeSet; // Set of changes.<br/>end;<br/>TKMTileChangeTypeSet = set of TKMTileChangeType<br/>TKMTileChangeType =<br/>  (tctTerrain, tctRotation, tctHeight, tctObject)</pre>ChangeSet determines what should be changed on tile<br/>F.e. if we want to change terrain type and height, then ChangeSet should contain tctTerrain and tctHeight<br/>Note: aTiles elements should start from 0, as for dynamic array. So f.e. to change map tile 1,1 we should set aTiles[0][0].<br/>Note: Errors are shown as map tiles (f.e. for error while applying aTiles[0][0] tile there will be a message with for map tile 1,1)<br/><br/>Returns true, if there was no errors on any tile. False if there was at least 1 error.</sub> | <sub>**aTiles**: array of TKMTerrainTileBrief; //_Check detailed info on this type in description_ <br> **aRevertOnFail**: Boolean; //_do we need to revert all changes on any error while applying changes. If True, then no changes will be applied on error. If False - we will continue apply changes where possible_ <br> **aShowDetailedErrors**: Boolean; //_show detailed errors after. Can slow down the execution, because of logging. If aRevertOnFail is set to True, then only first error will be shown_</sub> | <sub>Boolean</sub> |
| 7000+ | MapTilesArraySetS<sub><br/>Sets array of tiles info, like MapTilesArraySet, but parameters are<br/>passed as an TAnsiStringArray instead of array of TKMTerrainTileBrief.<br/>This function is useful if you need to create dynamic map from scratch.<br/>Array must contain strings in following format: 'X,Y,Terrain,Rotation,Height,Obj'<br/>f.e. '1,1,20,2,87,12'<br/>In case of invalid structure detection / failed variable parsing you can find<br/>detailed errors in LOG file.<br/>If you need to skip terrain or rotation/height/obj use -1 as parameter<br/>f.e.<br/>Skipping rotation for tile [7,2]: '7,2,20,-1,87,12'<br/>Skipping obj for tile [7,2]: '7,2,20,2,87,-1'<br/>Skipping height for tile [7,2]: '7,2,20,2,-1,5' etc.</sub> | <sub>**aTilesS**: array of AnsiString; <br> **aRevertOnFail**: Boolean; <br> **aShowDetailedErrors**: Boolean;</sub> | <sub>Boolean</sub> |
| 6587 | MapTileSet<sub><br/>Sets the tile type and rotation at the specified XY coordinates.<br/>Tile IDs can be seen by hovering over the tiles on the terrain tiles tab in the map editor.<br/>Returns true if the change succeeded or false if it failed.<br/>The change will fail if it would cause a unit to become stuck or a house/field to be damaged</sub> | <sub>**X**: Integer; <br> **Y**: Integer; <br> **aType**: Integer; //_Tile type (0..255)_ <br> **aRotation**: Integer; //_Tile rotation (0..3)_</sub> | <sub>Boolean</sub> |
| 6216 | MarketSetTrade<sub><br/>Sets the trade in the specified market</sub> | <sub>**aMarketID**: Integer; <br> **aFrom**: Integer; <br> **aTo**: Integer; <br> **aAmount**: Integer;</sub> | <sub></sub> |
| 5333 | OverlayTextAppend<sub><br/>Appends to text overlaid on top left of screen.<br/>If the player index is -1 it will be appended for all players.</sub> | <sub>**aPlayer**: Shortint; <br> **aText**: AnsiString;</sub> | <sub></sub> |
| 5333 | OverlayTextAppendFormatted<sub><br/>Appends to text overlaid on top left of screen with formatted arguments (same as Format function).<br/>If the player index is -1 it will be appended for all players.</sub> | <sub>**aPlayer**: Shortint; <br> **aText**: AnsiString; <br> **Params**: array of const; //_Array of arguments_</sub> | <sub></sub> |
| 5333 | OverlayTextSet<sub><br/>Sets text overlaid on top left of screen.<br/>If the player index is -1 it will be set for all players.</sub> | <sub>**aPlayer**: Shortint; <br> **aText**: AnsiString;</sub> | <sub></sub> |
| 5333 | OverlayTextSetFormatted<sub><br/>Sets text overlaid on top left of screen with formatted arguments (same as Format function).<br/>If the player index is -1 it will be set for all players.</sub> | <sub>**aPlayer**: Shortint; <br> **aText**: AnsiString; <br> **Params**: array of const; //_Array of arguments_</sub> | <sub></sub> |
| 5057 | PlanAddField<sub><br/>Adds a corn field plan.<br/>Returns true if the plan was successfully added or false if it failed (e.g. tile blocked)</sub> | <sub>**aPlayer**: Word; <br> **X**: Word; <br> **Y**: Word;</sub> | <sub>Boolean</sub> |
| 5057 | PlanAddHouse<sub><br/>Adds a road plan.<br/>Returns true if the plan was successfully added or false if it failed (e.g. tile blocked)</sub> | <sub>**aPlayer**: Word; <br> **aHouseType**: Word; <br> **X**: Word; <br> **Y**: Word;</sub> | <sub>Boolean</sub> |
| 5057 | PlanAddRoad<sub><br/>Adds a road plan.<br/>Returns true if the plan was successfully added or false if it failed (e.g. tile blocked)</sub> | <sub>**aPlayer**: Word; <br> **X**: Word; <br> **Y**: Word;</sub> | <sub>Boolean</sub> |
| 5057 | PlanAddWinefield<sub><br/>Adds a wine field plan.<br/>Returns true if the plan was successfully added or false if it failed (e.g. tile blocked)</sub> | <sub>**aPlayer**: Word; <br> **X**: Word; <br> **Y**: Word;</sub> | <sub>Boolean</sub> |
| 6303 | PlanConnectRoad<sub><br/>Connects road plans between two points like AI builder and returns True if road plan was successfully added.<br/>If CompletedRoad = True, road will be added instead of plans</sub> | <sub>**aPlayer**: Integer; <br> **X1**: Integer; //_Left coordinate_ <br> **Y1**: Integer; //_Top coordinate_ <br> **X2**: Integer; //_Right coordinate_ <br> **Y2**: Integer; //_Bottom coordinate_ <br> **aCompleted**: Boolean; //_Completed road_</sub> | <sub>Boolean</sub> |
| 5345 | PlanRemove<sub><br/>Removes house, road or field plans from the specified tile for the specified player<br/>Returns true if the plan was successfully removed or false if it failed (e.g. tile blocked)</sub> | <sub>**aPlayer**: Word; <br> **X**: Word; <br> **Y**: Word;</sub> | <sub>Boolean</sub> |
| 5165 | PlayerAddDefaultGoals<sub><br/>Add default goals/lost goals for the specified player.<br/>If the parameter buildings is true the goals will be important buildings.<br/>Otherwise it will be troops.</sub> | <sub>**aPlayer**: Byte; <br> **aBuildings**: Boolean;</sub> | <sub></sub> |
| 5097 | PlayerAllianceChange<sub><br/>Change whether player1 is allied to player2.<br/>If Compliment is true, then it is set both ways (so also whether player2 is allied to player1)</sub> | <sub>**aPlayer1**: Byte; <br> **aPlayer2**: Byte; <br> **aCompliment**: Boolean; //_Both ways_ <br> **aAllied**: Boolean;</sub> | <sub></sub> |
| 7000+ | PlayerAllianceNFogChange<sub><br/>Change whether player1 is allied to player2.<br/>If Compliment is true, then it is set both ways (so also whether player2 is allied to player1)</sub> | <sub>**aPlayer1**: Byte; <br> **aPlayer2**: Byte; <br> **aCompliment**: Boolean; //_Both ways_ <br> **aAllied**: Boolean; <br> **aSyncAllyFog**: Boolean; //_Synchronize allies fogs of war_</sub> | <sub></sub> |
| 5057 | PlayerDefeat<sub><br/>Proclaims player defeated</sub> | <sub>**aPlayer**: Word;</sub> | <sub></sub> |
| 7000+ | PlayerShareBeacons<sub><br/>Sets whether player A shares his beacons with player B.<br/>Sharing can still only happen between allied players, but this command lets you disable allies from sharing.</sub> | <sub>**aPlayer1**: Word; <br> **aPlayer2**: Word; <br> **aBothWays**: Boolean; //_share in both ways_ <br> **aShare**: Boolean;</sub> | <sub></sub> |
| 5345 | PlayerShareFog<sub><br/>Sets whether player A shares his vision with player B (one way, for both ways use PlayerShareFogCompliment).<br/>Sharing can still only happen between allied players, but this command lets you disable allies from sharing.</sub> | <sub>**aPlayer1**: Word; <br> **aPlayer2**: Word; <br> **aShare**: Boolean;</sub> | <sub></sub> |
| 7000+ | PlayerShareFogCompliment<sub><br/>Sets whether players A and B share their vision (both ways).<br/>Sharing can still only happen between allied players, but this command lets you disable allies from sharing.</sub> | <sub>**aPlayer1**: Word; <br> **aPlayer2**: Word; <br> **aShare**: Boolean;</sub> | <sub></sub> |
| 5345 | PlayerWareDistribution<sub><br/>Sets ware distribution for the specified resource, house and player.</sub> | <sub>**aPlayer**: Byte; <br> **aWareType**: Byte; <br> **aHouseType**: Byte; <br> **aAmount**: Byte; //_Distribution amount (0..5)_</sub> | <sub></sub> |
| 5057 | PlayerWin<sub><br/>Set specified player(s) victorious, and all team members of those player(s) if the 2nd parameter TeamVictory is set to true.<br/>All players who were not set to victorious are set to defeated.</sub> | <sub>**aVictors**: array of Integer; //_Array of player IDs_ <br> **aTeamVictory**: Boolean;</sub> | <sub></sub> |
| 7000+ | PlayOGG<sub><br/>Plays OGG audio file.<br/>If the player index is -1 the sound will be played to all players.<br/>Mono and stereo OGG files are supported.<br/>OGG file goes in mission folder named: Mission Name.filename.ogg</sub> | <sub>**aPlayer**: Shortint; <br> **aFileName**: AnsiString; <br> **aVolume**: Single; //_Audio level (0.0 to 1.0)_</sub> | <sub>Integer //SoundIndex of the sound</sub> |
| 7000+ | PlayOGGAtLocation<sub><br/>Plays OGG audio file at a location on the map.<br/>If the player index is -1 the sound will be played to all players.<br/>Radius specifies approximately the distance at which the sound can no longer be heard (normal game sounds use radius 32).<br/>Only mono OGG files are supported.<br/>OGG file goes in mission folder named: Mission Name.filename.ogg.<br/>Will not play if the location is not revealed to the player.<br/>Higher volume range is allowed than PlayOGG as positional sounds are quieter</sub> | <sub>**aPlayer**: Shortint; <br> **aFileName**: AnsiString; <br> **aVolume**: Single; //_Audio level (0.0 to 4.0)_ <br> **aRadius**: Single; //_Radius (minimum 28)_ <br> **aX**: Word; <br> **aY**: Word;</sub> | <sub>Integer //SoundIndex of the sound</sub> |
| 7000+ | PlayOGGAtLocationLooped<sub><br/>Plays looped audio file at a location on the map.<br/>If the player index is -1 the sound will be played to all players.<br/>aRadius specifies approximately the distance at which the sound can no longer be heard (normal game sounds use aRadius 32).<br/>Only mono OGG files are supported.<br/>OGG file goes in mission folder named: Mission Name.filename.ogg.<br/>Will not play if the location is not revealed to the player (will start playing automatically when it is revealed).<br/>Higher aVolume range is allowed than PlayOGG as positional sounds are quieter.<br/>The sound will continue to loop if the game is paused and will restart automatically when the game is loaded.</sub> | <sub>**aPlayer**: Shortint; <br> **aFileName**: AnsiString; <br> **aVolume**: Single; //_Audio level (0.0 to 4.0)_ <br> **aRadius**: Single; //_aRadius (minimum 28)_ <br> **aX**: Word; <br> **aY**: Word;</sub> | <sub>Integer //SoundIndex of the sound</sub> |
| 7000+ | PlayOGGFadeMusic<sub><br/>Same as PlayOGG except music will fade then mute while the OGG is playing, then fade back in afterwards.<br/>You should leave a small gap at the start of your OGG file to give the music time to fade</sub> | <sub>**aPlayer**: Shortint; <br> **aFileName**: AnsiString; <br> **aVolume**: Single; //_Audio level (0.0 to 1.0)_</sub> | <sub>Integer //SoundIndex of the sound</sub> |
| 7000+ | PlayOGGLooped<sub><br/>Plays looped OGG audio file.<br/>If the player index is -1 the sound will be played to all players.<br/>Mono or stereo OGG files are supported.<br/>OGG file goes in mission folder named: Mission Name.filename.ogg.<br/>The sound will continue to loop if the game is paused and will restart automatically when the game is loaded.</sub> | <sub>**aPlayer**: Shortint; <br> **aFileName**: AnsiString; <br> **aVolume**: Single; //_Audio level (0.0 to 1.0)_</sub> | <sub>Integer //SoundIndex of the sound</sub> |
| 7000+ | PlaySound<sub><br/>Plays audio file.<br/>If the player index is -1 the sound will be played to all players.<br/>Possible to specify Looped or FadeMusic parameter<br/>Mono and stereo WAV and OGG files are supported.<br/>To specify audio format use afWav or afOgg<br/>WAV file goes in mission folder named: Mission Name.filename.wav.<br/>OGG file goes in mission folder named: Mission Name.filename.ogg<br/>If MusicFaded then sound will fade then mute while the file is playing, then fade back in afterwards.<br/>If looped, the sound will continue to loop if the game is paused and will restart automatically when the game is loaded.</sub> | <sub>**aPlayer**: Shortint; <br> **aFileName**: AnsiString; <br> **aAudioFormat**: TKMAudioFormat; //_afWav or afOgg_ <br> **aVolume**: Single; //_Audio level (0.0 to 1.0)_ <br> **aFadeMusic**: Boolean; <br> **aLooped**: Boolean;</sub> | <sub>Integer //SoundIndex of the sound</sub> |
| 7000+ | PlaySoundAtLocation<sub><br/>Plays audio file at a location on the map.<br/>If the player index is -1 the sound will be played to all players.<br/>Possible to specify Looped or FadeMusic parameter<br/>aRadius specifies approximately the distance at which the sound can no longer be heard (normal game sounds use aRadius 32).<br/>Only mono WAV or OGG files are supported.<br/>To specify audio format use afWav or afOgg<br/>WAV file goes in mission folder named: Mission Name.filename.wav.<br/>OGG file goes in mission folder named: Mission Name.filename.ogg.<br/>Will not play if the location is not revealed to the player (will start playing automatically when it is revealed).<br/>Higher aVolume range is allowed than PlaySound as positional sounds are quieter.<br/>If looped, the sound will continue to loop if the game is paused and will restart automatically when the game is loaded.</sub> | <sub>**aPlayer**: Shortint; <br> **aFileName**: AnsiString; <br> **aAudioFormat**: TKMAudioFormat; //_afWav or afOgg_ <br> **aVolume**: Single; //_Audio level (0.0 to 4.0)_ <br> **aFadeMusic**: Boolean; <br> **aLooped**: Boolean; <br> **aRadius**: Single; //_aRadius (minimum 28)_ <br> **aX**: Word; <br> **aY**: Word;</sub> | <sub>Integer //SoundIndex of the sound</sub> |
| 5309 | PlayWAV<sub><br/>Plays WAV audio file.<br/>If the player index is -1 the sound will be played to all players.<br/>Mono and stereo WAV files are supported.<br/>WAV file goes in mission folder named: Mission Name.filename.wav</sub> | <sub>**aPlayer**: Shortint; <br> **aFileName**: AnsiString; <br> **aVolume**: Single; //_Audio level (0.0 to 1.0)_</sub> | <sub>Integer //SoundIndex of the sound</sub> |
| 5309 | PlayWAVAtLocation<sub><br/>Plays WAV audio file at a location on the map.<br/>If the player index is -1 the sound will be played to all players.<br/>Radius specifies approximately the distance at which the sound can no longer be heard (normal game sounds use radius 32).<br/>Only mono WAV files are supported.<br/>WAV file goes in mission folder named: Mission Name.filename.wav.<br/>Will not play if the location is not revealed to the player.<br/>Higher volume range is allowed than PlayWAV as positional sounds are quieter</sub> | <sub>**aPlayer**: Shortint; <br> **aFileName**: AnsiString; <br> **aVolume**: Single; //_Audio level (0.0 to 4.0)_ <br> **aRadius**: Single; //_Radius (minimum 28)_ <br> **aX**: Word; <br> **aY**: Word;</sub> | <sub>Integer //SoundIndex of the sound</sub> |
| 6222 | PlayWAVAtLocationLooped<sub><br/>Plays looped WAV audio file at a location on the map.<br/>If the player index is -1 the sound will be played to all players.<br/>aRadius specifies approximately the distance at which the sound can no longer be heard (normal game sounds use aRadius 32).<br/>Only mono WAV files are supported.<br/>WAV file goes in mission folder named: Mission Name.filename.wav.<br/>Will not play if the location is not revealed to the player (will start playing automatically when it is revealed).<br/>Higher aVolume range is allowed than PlayWAV as positional sounds are quieter.<br/>The sound will continue to loop if the game is paused and will restart automatically when the game is loaded.</sub> | <sub>**aPlayer**: Shortint; <br> **aFileName**: AnsiString; <br> **aVolume**: Single; //_Audio level (0.0 to 4.0)_ <br> **aRadius**: Single; //_aRadius (minimum 28)_ <br> **aX**: Word; <br> **aY**: Word;</sub> | <sub>Integer //SoundIndex of the sound</sub> |
| 6220 | PlayWAVFadeMusic<sub><br/>Same as PlayWAV except music will fade then mute while the WAV is playing, then fade back in afterwards.<br/>You should leave a small gap at the start of your WAV file to give the music time to fade</sub> | <sub>**aPlayer**: Shortint; <br> **aFileName**: AnsiString; <br> **aVolume**: Single; //_Audio level (0.0 to 1.0)_</sub> | <sub>Integer //SoundIndex of the sound</sub> |
| 6222 | PlayWAVLooped<sub><br/>Plays looped audio file.<br/>If the player index is -1 the sound will be played to all players.<br/>Mono or stereo WAV files are supported.<br/>WAV file goes in mission folder named: Mission Name.filename.wav.<br/>The sound will continue to loop if the game is paused and will restart automatically when the game is loaded.</sub> | <sub>**aPlayer**: Shortint; <br> **aFileName**: AnsiString; <br> **aVolume**: Single; //_Audio level (0.0 to 1.0)_</sub> | <sub>Integer //SoundIndex of the sound</sub> |
| 5927 | RemoveRoad<sub><br/>Removes road</sub> | <sub>**X**: Word; <br> **Y**: Word;</sub> | <sub></sub> |
| 5057 | SetTradeAllowed<sub><br/>Sets whether the player is allowed to trade the specified resource.</sub> | <sub>**aPlayer**: Word; <br> **aResType**: Word; <br> **aAllowed**: Boolean;</sub> | <sub></sub> |
| 5057 | ShowMsg<sub><br/>Displays a message to a player.<br/>If the player index is -1 the message will be shown to all players.</sub> | <sub>**aPlayer**: Shortint; <br> **aText**: AnsiString;</sub> | <sub></sub> |
| 5333 | ShowMsgFormatted<sub><br/>Displays a message to a player with formatted arguments (same as Format function).<br/>If the player index is -1 the message will be shown to all players.</sub> | <sub>**aPlayer**: Shortint; <br> **aText**: AnsiString; <br> **Params**: array of const; //_Array of arguments_</sub> | <sub></sub> |
| 5345 | ShowMsgGoto<sub><br/>Displays a message to a player with a goto button that takes the player to the specified location.<br/>If the player index is -1 the message will be shown to all players.</sub> | <sub>**aPlayer**: Shortint; <br> **aX**: Word; <br> **aY**: Word; <br> **aText**: AnsiString;</sub> | <sub></sub> |
| 5345 | ShowMsgGotoFormatted<sub><br/>Displays a message to a player with formatted arguments (same as Format function)<br/>and a goto button that takes the player to the specified location.<br/>If the player index is -1 the message will be shown to all players.</sub> | <sub>**aPlayer**: Shortint; <br> **aX**: Word; <br> **aY**: Word; <br> **aText**: AnsiString; <br> **Params**: array of const; //_Array of arguments_</sub> | <sub></sub> |
| 7000+ | StopLoopedOGG<sub><br/>Stops playing a looped sound that was previously started with either Actions.PlayOGGLooped or Actions.PlayOGGAtLocationLooped.</sub> | <sub>**aSoundIndex**: Integer; //_value that was returned by either of those functions when the looped sound was started._</sub> | <sub></sub> |
| 6222 | StopLoopedWAV<sub><br/>Stops playing a looped sound that was previously started with either Actions.PlayWAVLooped or Actions.PlayWAVAtLocationLooped.</sub> | <sub>**aSoundIndex**: Integer; //_value that was returned by either of those functions when the looped sound was started._</sub> | <sub></sub> |
| 7000+ | StopSound<sub><br/>Stops playing any sound that was previously started by any of PlayWAV***, PlayOGG*** or PlaySound*** functions</sub> | <sub>**aSoundIndex**: Integer; //_value that was returned by either of those functions when the sound was started._</sub> | <sub></sub> |
| 5993 | UnitBlock<sub><br/>Sets whether the specified player can train/equip the specified unit type</sub> | <sub>**aPlayer**: Byte; <br> **aType**: Word; <br> **aBlock**: Boolean;</sub> | <sub></sub> |
| 5057 | UnitDirectionSet<sub><br/>Makes the specified unit face a certain direction.<br/>Note: Only works on idle units so as not to interfere with game logic and cause crashes.<br/>Returns true on success or false on failure.</sub> | <sub>**aUnitID**: Integer; <br> **aDirection**: Integer;</sub> | <sub>Boolean</sub> |
| 7000+ | UnitDismiss<sub><br/>Dismiss the specified unit</sub> | <sub>**aUnitID**: Integer;</sub> | <sub></sub> |
| 7000+ | UnitDismissableSet<sub><br/>Makes the specified unit 'dismiss' command available</sub> | <sub>**aUnitID**: Integer; <br> **aDismissable**: Boolean;</sub> | <sub></sub> |
| 7000+ | UnitDismissCancel<sub><br/>Cancel dismiss task for the specified unit</sub> | <sub>**aUnitID**: Integer;</sub> | <sub></sub> |
| 7000+ | UnitHPChange<sub><br/>Heals/Wounds specified unit for aHP HP</sub> | <sub>**aUnitID**: Integer; <br> **aHP**: Integer;</sub> | <sub></sub> |
| 7000+ | UnitHPSetInvulnerable<sub><br/>Makes the unit invulnerable. Such unit can not be killed or die from hunger.</sub> | <sub>**aUnitID**: Integer; <br> **aInvulnerable**: Boolean;</sub> | <sub></sub> |
| 5057 | UnitHungerSet<sub><br/>Sets the hunger level of the specified unit in ticks until death</sub> | <sub>**aUnitID**: Integer; <br> **aHungerLevel**: Integer; //_Hunger level (ticks until death)_</sub> | <sub></sub> |
| 5099 | UnitKill<sub><br/>Kills the specified unit.<br/>Silent means the death animation (ghost) and sound won't play</sub> | <sub>**aUnitID**: Integer; <br> **aSilent**: Boolean;</sub> | <sub></sub> |
| 5057 | UnitOrderWalk<sub><br/>Order the specified unit to walk somewhere.<br/>Note: Only works on idle units so as not to interfere with game logic and cause crashes.<br/>Returns true on success or false on failure.</sub> | <sub>**aUnitID**: Integer; <br> **X**: Word; <br> **Y**: Word;</sub> | <sub>Boolean</sub> |
